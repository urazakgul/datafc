import json
import pandas as pd
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
from datafc.utils._setup_webdriver import setup_webdriver
from datafc.utils._save_files import save_json, save_excel
from datafc.utils._config import ALLOWED_SOURCES, API_BASE_URLS

def lineups_data(
    match_df: pd.DataFrame,
    data_source: str = "sofascore",
    element_load_timeout: int = 10,
    enable_json_export: bool = False,
    enable_excel_export: bool = False
) -> pd.DataFrame:
    """
    Fetches lineup data for each match in the provided match dataset.

    Args:
        match_df (pd.DataFrame): A DataFrame containing match metadata,
            which should be generated by the `match_data` function.
        data_source (str): The data source ('sofavpn' or 'sofascore'). Defaults to 'sofascore'.
        element_load_timeout (int): The maximum time (in seconds) to wait for the API response. Defaults to 10.
        enable_json_export (bool): If `True`, saves the fetched data as a JSON file. Defaults to `False`.
        enable_excel_export (bool): If `True`, saves the fetched data as an Excel file. Defaults to `False`.
    """
    if data_source not in ALLOWED_SOURCES:
        raise ValueError(f"Invalid data source: {data_source}. Must be one of {ALLOWED_SOURCES}")

    if match_df is None or match_df.empty:
        raise ValueError("Match dataframe must be provided and cannot be empty.")

    webdriver_instance = None
    try:
        webdriver_instance = setup_webdriver()
        lineups_data_df = pd.DataFrame()

        def process_player_statistics(lineups_data, team_key):
            extracted_data = []
            for _, row in lineups_data.iterrows():
                for player in row[team_key]:
                    for stat_name, stat_value in player.get("statistics", {}).items():
                        extracted_data.append({
                            "country": row["country"],
                            "tournament": row["tournament"],
                            "season": row["season"],
                            "week": row["week"],
                            "game_id": row["game_id"],
                            "team": team_key,
                            "player_name": player["player"]["name"],
                            "player_id": player["player"]["id"],
                            "stat_name": stat_name,
                            "stat_value": stat_value
                        })
            return extracted_data

        for _, row in match_df.iterrows():
            country = row["country"]
            tournament = row["tournament"]
            game_id = row["game_id"]
            season = row["season"]
            week = row["week"]

            url = f"{API_BASE_URLS[data_source]}/api/v1/event/{game_id}/lineups"
            webdriver_instance.get(url)

            try:
                pre_tag = WebDriverWait(webdriver_instance, element_load_timeout).until(
                    EC.visibility_of_element_located((By.TAG_NAME, "pre"))
                )

                lineups_json = json.loads(pre_tag.text)
                lineups_data = pd.DataFrame.from_dict(lineups_json)
                lineups_data["country"] = country
                lineups_data["tournament"] = tournament
                lineups_data["season"] = season
                lineups_data["week"] = week
                lineups_data["game_id"] = game_id

                lineups_data = lineups_data[lineups_data.index == "players"]
                lineups_data_df = pd.concat([lineups_data_df, lineups_data], ignore_index=True)

            except TimeoutException:
                raise RuntimeError(f"Timeout while fetching lineup data for game_id {game_id}.")
            except json.JSONDecodeError:
                raise RuntimeError(f"Failed to decode lineup data for game_id {game_id}.")
            except WebDriverException as e:
                raise RuntimeError(f"Selenium WebDriver error while fetching lineup data for game_id {game_id}: {str(e)}")
            except Exception as e:
                raise RuntimeError(f"Unexpected error while fetching lineup data for game_id {game_id}: {e.__class__.__name__} - {e}")

        if lineups_data_df.empty:
            raise ValueError("No lineup data found for the specified parameters.")

        extracted_lineups_data = []
        for team_key in ["home", "away"]:
            extracted_lineups_data.extend(process_player_statistics(lineups_data_df, team_key))

        extracted_lineups_data_df = pd.DataFrame(extracted_lineups_data)

        def extract_original_rating(rating_versions):
            if isinstance(rating_versions, dict) and "original" in rating_versions:
                return rating_versions["original"]
            return rating_versions

        extracted_lineups_data_df["stat_value"] = extracted_lineups_data_df.apply(
            lambda row: extract_original_rating(row["stat_value"]) if row["stat_name"] == "ratingVersions" else row["stat_value"],
            axis=1
        )

        if extracted_lineups_data_df.empty:
            raise ValueError("No extracted lineup data available.")

        if enable_json_export or enable_excel_export:
            first_row = extracted_lineups_data_df.iloc[0]

            if enable_json_export:
                save_json(
                    data=extracted_lineups_data_df,
                    country=first_row["country"],
                    tournament=first_row["tournament"],
                    season=first_row["season"],
                    week_number=first_row["week"]
                )

            if enable_excel_export:
                save_excel(
                    data=extracted_lineups_data_df,
                    country=first_row["country"],
                    tournament=first_row["tournament"],
                    season=first_row["season"],
                    week_number=first_row["week"]
                )

        return extracted_lineups_data_df

    except WebDriverException as e:
        raise RuntimeError(f"Selenium WebDriver error: {str(e)}")
    except Exception as e:
        raise RuntimeError(f"Unexpected error while fetching lineup data: {e.__class__.__name__} - {e}")

    finally:
        if webdriver_instance:
            webdriver_instance.quit()